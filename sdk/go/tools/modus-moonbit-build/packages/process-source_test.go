/*
 * Copyright 2024 Hypermode Inc.
 * Licensed under the terms of the Apache License, Version 2.0
 * See the LICENSE file that accompanied this code for further details.
 *
 * SPDX-FileCopyrightText: 2024 Hypermode Inc. <hello@hypermode.com>
 * SPDX-License-Identifier: Apache-2.0
 */

package packages

import (
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestImportedHostFnRE(t *testing.T) {
	t.Parallel()
	tests := []struct {
		name string
		src  string
		want [][]string
	}{
		{
			name: "neo4j",
			src: `// Generated by wit-bindgen 0.36.0. DO NOT EDIT!

///|modus:import modus_neo4j_client executeQuery(host_name : String, db_name : String, query : String, parameters_json : Map[String, Json]) -> EagerResult? raise Error
fn wasmImportExecuteQuery(
  host_name : Int,
  db_name : Int,
  query : Int,
  parameters_json : Int
) -> Int = "modus_neo4j_client" "executeQuery"
`,
			want: [][]string{
				{
					`fn wasmImportExecuteQuery(
  host_name : Int,
  db_name : Int,
  query : Int,
  parameters_json : Int
) -> Int = "modus_neo4j_client" "executeQuery"`,
					`
  host_name : Int,
  db_name : Int,
  query : Int,
  parameters_json : Int
`,
					"-> Int ",
					"modus_neo4j_client",
					"executeQuery",
				},
			},
		},
		{
			name: "host_encode_strings2",
			src: `
fn host_encode_strings1(items : Array[String]?) -> String? {
  let result = match items {
    None => _host_encode_strings1(0)
    Some(m) => {
      let ptr : Int = cast(items)
      _host_encode_strings1(ptr)
    }
  }
  match result {
    0 => None
    _ => Some(@ffi.ptr2str(result + 8))
  }
}

fn _host_encode_strings2(items : Int) -> Int = "modus_test" "encodeStrings2"
`,
			want: [][]string{
				{
					`fn _host_encode_strings2(items : Int) -> Int = "modus_test" "encodeStrings2"`,
					"items : Int",
					"-> Int ",
					"modus_test",
					"encodeStrings2",
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			got := importedHostFnRE.FindAllStringSubmatch(tt.src, -1)
			if diff := cmp.Diff(tt.want, got); diff != "" {
				t.Errorf("importedHostFnRE mismatch (-want +got):\n%v", diff)
			}
		})
	}
}

func TestPubFnRE(t *testing.T) {
	t.Parallel()
	tests := []struct {
		name string
		src  string
		want [][]string
	}{
		{
			name: "runtime",
			src: `

///|
pub fn __modus_test_fixedarray_output_float_option_1_none() -> FixedArray[
  Float?,
] {
  test_fixedarray_output_float_option_1_none()
}
`,
			want: [][]string{
				{
					`
pub fn __modus_test_fixedarray_output_float_option_1_none() -> FixedArray[
  Float?,
] {`,
					"__modus_test_fixedarray_output_float_option_1_none() -> FixedArray[\n  Float?,\n]",
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			got := pubFnRE.FindAllStringSubmatch(tt.src, -1)
			if diff := cmp.Diff(tt.want, got); diff != "" {
				t.Errorf("pubFnRE mismatch (-want +got):\n%v", diff)
			}
		})
	}
}

func TestSanitizeFnSignature(t *testing.T) {
	t.Parallel()
	tests := []struct {
		name       string
		wantFn     string
		wantReturn string
	}{
		{
			name:       "__modus_test_fixedarray_output_float_option_1_none() -> FixedArray[\n  Float?,\n]",
			wantFn:     "__modus_test_fixedarray_output_float_option_1_none()",
			wantReturn: "FixedArray[Float?]",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			gotFn, gotReturn, ok := sanitizeFnSignature(tt.name)
			if !ok {
				t.Fatalf("sanitizeFnSignature(%q) ok = false, want true", tt.name)
			}

			if gotFn != tt.wantFn {
				t.Errorf("sanitizeFnSignature(%q) fn = '%v', want '%v'", tt.name, gotFn, tt.wantFn)
			}

			if gotReturn != tt.wantReturn {
				t.Errorf("sanitizeFnSignature(%q) return = '%v', want '%v'", tt.name, gotReturn, tt.wantReturn)
			}
		})
	}
}

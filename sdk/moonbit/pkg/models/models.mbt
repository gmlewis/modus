// Copyright 2024 Hypermode Inc.
// Licensed under the terms of the Apache License, Version 2.0
// See the LICENSE file that accompanied this code for further details.
//
// SPDX-FileCopyrightText: 2024 Hypermode Inc. <hello@hypermode.com>
// SPDX-License-Identifier: Apache-2.0

///| The models package provides a generic interface for invoking various AI models.

///| Provides information about a model.
typealias ModelInfo = @host.ModelInfo

///| Provides a generic interface for interacting with an AI model.
pub(open) trait Model {
  info(Self) -> ModelInfo
  invoke(Self, Json) -> Json!Error
}

///| Provides a generic interface for setting the model information (used internally).
trait ModelPtr {
  set_info(Self, ModelInfo) -> Unit
}

///| Provides a base implementation for all models.
pub(all) struct ModelBase {
  mut info : ModelInfo?
  debug : Bool
}

///|
pub impl Model for ModelBase with info(self) { self.info.unwrap() }

///|
pub impl ModelPtr for ModelBase with set_info(self, info) {
  self.info = Some(info)
}

///|
type! ModelError String derive(Show, Eq)

///| Gets a model object instance, which can be used to interact with the model.
///   - The generic type parameter [TModel] is used to specify the API that the model adheres to.
///   - The name parameter is used to identify the model in the modus.json manifest file.
///
/// Note that of the generic type parameters, only [TModel] needs to be specified.  The others are inferred automatically.
pub fn get_model(name : String) -> ModelBase!Error {
  let info = @host.get_model_info(name)
  if info.is_empty() {
    raise ModelError("model not found: \{name}")
  }
  ModelBase::{ info, debug: false }
}

///| Invokes the model with the specified input and returns the output generated by the model.
pub impl Model for ModelBase with invoke(self, input) {
  if self.info.is_empty() {
    raise ModelError(
      "model info is not set (use GetModel to create a model instance)",
    )
  }

  //
  let model_name = self.info.unwrap().name
  let input_json = @json.stringify(input)

  //
  if self.debug {
    @console.log("Invoking model \{model_name} with input: \{input_json}")
  }

  //
  let output_json = @host.invoke_model(model_name, input_json)
  if output_json.is_empty() {
    raise ModelError("failed to invoke model \{model_name}")
  }
  let output_json = output_json.unwrap()

  //
  if self.debug {
    @console.log("Received output for model \{model_name}: \{output_json}")
  }

  //
  let result = try {
    @json.parse!(output_json)
  } catch {
    e =>
      raise ModelError(
        "failed to deserialize model output for \{model_name}: \{e}",
      )
  }
  result
}

// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| Timekeeping
/// Get the resolution of a clock.
pub fn clock_res_get(clockid : UInt) -> Result[UInt64, UInt] {
  let return_area = @ffi.malloc(16)
  wasmImportClockResGet(clockid.reinterpret_as_int(), return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => Result::Err(@ffi.load32(return_area + 8).reinterpret_as_uint())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Get the current time of a clock.
pub fn clock_time_get(
  /// clockid: The clock for which to return the time.
  /// 0: Realtime
  /// 1: Monotonic
  /// 2: Process CPUTime
  /// 3: Thread CPUTime
  clockid : UInt,
  /// precision: The maximum lag (exclusive) that the returned time may have, compared to its actual value.
  /// Note that the precision parameter is simply a hint, but does not change the resolution of the result.
  precision : UInt64
) -> Result[UInt64, UInt] {
  let return_area = @ffi.malloc(8)
  let result = wasmImportClockTimeGet(
    clockid.reinterpret_as_int(),
    precision.reinterpret_as_int64(),
    return_area,
  )
  let lifted = match result {
    0 => Result::Ok(@ffi.load64(return_area).reinterpret_as_uint64())
    _ => Result::Err(result.reinterpret_as_uint())
  }
  @ffi.free(return_area)
  return lifted
}

///| Random Number Generation
/// Fill a buffer with random data.
pub fn random_get(buf : String, buf_len : UInt) -> Result[Unit, UInt] {
  let return_area = @ffi.malloc(8)
  wasmImportRandomGet(
    @ffi.str2ptr(buf),
    buf.iter().count(),
    buf_len.reinterpret_as_int(),
    return_area,
  )
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => Result::Err(@ffi.load32(return_area + 4).reinterpret_as_uint())
    _ => panic()
  }
  ignore(buf)
  @ffi.free(return_area)
  return lifted
}

///| Get an environment variable.
pub fn environ_get(name : String) -> String {
  if name == "" {
    return ""
  }

  //
  let utf8_key = @base64.str2array("\{name}=") // e.g. "TZ="
  let (errno, environc, environ_buf_size) = environ_sizes_get()
  let environ = @ffi.malloc(environc * 4) // space for `Pointer<Pointer<u8>>`
  let environ_buf = @ffi.malloc(environ_buf_size) // space for `Pointer<u8>`
  let result = wasmImportEnvironGet(environ, environ_buf)
  if result != 0 {
    println("environ_get: error: \{result}")
    return ""
  }

  //
  let mut result = ""
  for i in 0..<environc {
    let offset = @ffi.load32(environ + i * 4)
    if bytes_at_offset_match(offset, utf8_key) {
      result = read_utf8_string_at_offset(offset + utf8_key.length())
      break
    }
  }
  @ffi.free(environ)
  @ffi.free(environ_buf)
  result
}

///|
fn bytes_at_offset_match(offset : Int, bytes : Array[Byte]) -> Bool {
  for i in 0..<bytes.length() {
    if @ffi.load8(offset + i).to_byte() != bytes[i] {
      return false
    }
  }
  true
}

///| This reads a zero-terminated UTF-8 string from the buffer at the given offset
/// and converts it to a MoonBit string.
fn read_utf8_string_at_offset(offset : Int) -> String {
  let bytes = []
  let mut i = 0
  while true {
    let byte = @ffi.load8(offset + i).to_byte()
    if byte == 0 {
      break
    }
    bytes.push(byte)
    i = i + 1
  }
  @base64.array2str(bytes[:])
}

///| Returns the number of environment variables and the total size of the
/// environment (null-terminated Go-style) strings.
///
/// - `errno`: The error code (0 for success).
/// - `environc`: The number of environment variables.
/// - `environ_buf_size`: The total size of the environment strings.
pub fn environ_sizes_get() -> (Int, Int, Int) {
  let return_area = @ffi.malloc(8)
  let errno = wasmImportEnvironSizesGet(return_area, return_area + 4)
  let environc = @ffi.load32(return_area + 0)
  let environ_buf_size = @ffi.load32(return_area + 4)
  @ffi.free(return_area)
  (errno, environc, environ_buf_size)
}

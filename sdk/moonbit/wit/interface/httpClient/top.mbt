// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| Headers type representation
pub(all) struct Headers {
  data : Array[(String, String)]
} derive(Show, Eq, FromJson, ToJson)

///| HTTP Request record
pub(all) struct Request {
  url : String
  method_ : String
  headers : Headers?
  body : String // TODO: Bytes
} derive(Show, Eq, FromJson, ToJson)

///| HTTP Response record
pub(all) struct Response {
  status : Int // TODO: UInt
  status_text : String
  headers : Headers?
  body : String // TODO: Bytes
} derive(Show, Eq, FromJson, ToJson)

///| Fetch performs an HTTP request and returns a response
pub fn fetch(request : Request) -> Response? {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let (lowered, lowered5, lowered6) = match request.headers {
    None => (0, 0, 0)
    Some(payload2) => {
      let address = @ffi.malloc(payload2.data.length() * 16)
      for index = 0; index < payload2.data.length(); index = index + 1 {
        let element3 : (String, String) = payload2.data[index]
        let base4 = address + index * 16
        @ffi.store32(base4 + 4, element3.0.iter().count())
        @ffi.store32(base4 + 0, @ffi.str2ptr(element3.0))
        @ffi.store32(base4 + 12, element3.1.iter().count())
        @ffi.store32(base4 + 8, @ffi.str2ptr(element3.1))
        ignoreList.push(element3.0)
        ignoreList.push(element3.1)
      }
      cleanupList.push({ address, size: payload2.data.length() * 16, align: 4 })
      (1, address, payload2.data.length())
    }
  }
  let return_area = @ffi.malloc(36)
  wasmImportFetch(
    @ffi.str2ptr(request.url),
    request.url.iter().count(),
    @ffi.str2ptr(request.method_),
    request.method_.iter().count(),
    lowered,
    lowered5,
    lowered6,
    // TODO: @ffi.bytes2ptr(request.body),
    @ffi.bytes2ptr(request.body.to_bytes()),
    request.body.length(),
    return_area,
  )
  let lifted21 : Response? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      ignore(@ffi.load32(return_area + 12))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
      let lifted : Headers? = match @ffi.load8_u(return_area + 16) {
        0 => Option::None
        1 => {
          let array : Array[(String, String)] = []
          for index19 = 0
              index19 < @ffi.load32(return_area + 24)
              index19 = index19 + 1 {
            let base16 = @ffi.load32(return_area + 20) + index19 * 16
            ignore(@ffi.load32(base16 + 4))
            let result17 = @ffi.ptr2str(@ffi.load32(base16 + 0))
            ignore(@ffi.load32(base16 + 12))
            let result18 = @ffi.ptr2str(@ffi.load32(base16 + 8))
            array.push((result17, result18))
          }
          @ffi.free(@ffi.load32(return_area + 20))
          Option::Some(Headers::{ data: array })
        }
        _ => panic()
      }
      ignore(@ffi.load32(return_area + 32))
      let result20 = @ffi.ptr2bytes(@ffi.load32(return_area + 28))
      Option::Some(Response::{
        status: @ffi.load16_u(return_area + 4) & 0xFFFF,
        // TODO: .reinterpret_as_uint(),
        status_text: result,
        headers: lifted,
        // TODO: body: result20,
        body: result20.to_unchecked_string(),
      })
    }
    _ => panic()
  }
  ignore(request.url)
  ignore(request.method_)
  ignore(request.body)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted21
}
